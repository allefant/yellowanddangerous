/* This file was generated by scramble.py. */
#line 1 "src/save.py"
#include "save.h"
#line 3
    /* Savegame format:
     * a block in the center is at 22, 4, 22
     * positions are multipled by 24 to obtain in-game positions
     * An isometric block's origin is the bottom back corner, x then goes right
     * down, y goes up, z goes left down.
     * y
     * |
     * |
     * |
     * _-´ `-_
     * _-´       `-_
     * z               x
     * A block at 22/4/22 will end up at 0/0/0.
     * A block at 0/0/0 will end up at -528,-96,-528. (-22*24,-4*42,-22*24)
     * A level's floor typically is 40 x 40 in size.
     */
#line 41
static SaveInfo g_save_info [50];
static void add(SaveInfo * si, float x, float y, float z, float xs, float ys, float zs);
#line 43
void save_info(void) {
    All * a = global_a;
    char * path = land_get_save_file("com.yellowdanger", "info.txt");
    LandFile * f = land_file_new(path, "w");
    config_print_controls(f);
    land_file_print(f, "room %d", game->level);
    land_file_print(f, "gox %d", game->gox);
    land_file_print(f, "goz %d", game->goz);
    land_file_print(f, "dpad %d", a->dpad);
    land_file_print(f, "fullscreen %d", a->fullscreen);
    land_file_print(f, "music %d", a->music);
    land_file_print(f, "sound %d", a->sound);
    land_file_print(f, "time %d", a->time);
    land_file_print(f, "key %d", game->key);
    land_file_print(f, "deaths %d", game->deaths);
    bool * fl = game->flower;
#line 60
    land_file_print(f, "flower %d %d %d %d %d %d %d", fl [1], fl [2], fl [3], fl [4], fl [5], fl [6], fl [7]);
    bool * tt = game->test_tube;
#line 63
    land_file_print(f, "testtube %d %d %d %d %d %d %d", tt [1], tt [2], tt [3], tt [4], tt [5], tt [6], tt [7]);
    land_file_destroy(f);
    land_free(path);
}
void load_info(void) {
    All * a = global_a;
    char * path = land_get_save_file("com.yellowdanger", "info.txt");
    game->level = game_starting_level;
    a->dpad = 0;
    a->music = 4;
    a->sound = 7;
    LandBuffer * f = land_buffer_read_from_file(path);
    if (f) {
        LandArray * rows = land_buffer_split(f, "\n");
        land_buffer_destroy(f);
        {
#line 78
            LandArrayIterator __iter0__ = LandArrayIterator_first(rows);
#line 78
            for (LandBuffer * rowb = LandArrayIterator_item(rows, &__iter0__); LandArrayIterator_next(rows, &__iter0__); rowb = LandArrayIterator_item(rows, &__iter0__)) {
                char * row = land_buffer_finish(rowb);
                config_read_controls(row);
                if (land_starts_with(row, "room ")) {
                    sscanf(row, "room %d", & game->level);
                }
#line 83
                if (land_starts_with(row, "gox ")) {
                    sscanf(row, "gox %d", & game->gox);
                }
#line 85
                if (land_starts_with(row, "goz ")) {
                    sscanf(row, "goz %d", & game->goz);
                }
#line 87
                if (land_starts_with(row, "dpad ")) {
                    sscanf(row, "dpad %d", & a->dpad);
                }
#line 89
                if (land_starts_with(row, "fullscreen ")) {
                    sscanf(row, "fullscreen %d", & a->fullscreen);
                }
#line 91
                if (land_starts_with(row, "music ")) {
                    sscanf(row, "music %d", & a->music);
                }
#line 93
                if (land_starts_with(row, "sound ")) {
                    sscanf(row, "sound %d", & a->sound);
                }
#line 95
                if (land_starts_with(row, "time ")) {
                    int t;
                    sscanf(row, "time %d", & t);
                    if (t > a->time) {
                        a->time = t;
                    }
                }
                // If a room is reloaded after dying or pausing,
                // we want to keep the current play time which
                // will always be higher.
                // If the game restarts however we want to use
                // the saved time.
#line 105
                if (land_starts_with(row, "key ")) {
                    int i;
                    sscanf(row, "key %d", & i);
                    if (i) {
#line 108
                        game->key = 1;
                    }
                }
#line 109
                if (land_starts_with(row, "deaths ")) {
                    sscanf(row, "deaths %d", & game->deaths);
                }
#line 111
                if (land_starts_with(row, "flower ")) {
                    int i [8];
                    i [0] = 0;
#line 115
                    sscanf(row, "flower %d %d %d %d %d %d %d", i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7);
                    for (int j = 0; j < 8; j += 1) {
                        game->flower [j] = i [j];
                    }
                }
#line 118
                if (land_starts_with(row, "testtube ")) {
                    int i [8];
                    i [0] = 0;
#line 122
                    sscanf(row, "testtube %d %d %d %d %d %d %d", i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7);
                    for (int j = 0; j < 8; j += 1) {
                        game->test_tube [j] = i [j];
                    }
                }
#line 125
                land_free(row);
            }
        }
#line 126
        land_array_destroy(rows);
    }
    land_free(path);
}
void save_get_name(char const * base, int level, char const * suffix, char * out) {
    sprintf(out, "%s%02d%s", base, level, suffix);
    char * path = land_get_save_file("com.yellowdanger", out);
    strcpy(out, path);
    land_free(path);
}
void save_level(bool editing, bool at_entrance) {
    char name [1024];
    if (editing) {
        sprintf(name, "data/levels/level%02d.txt", game->level);
        overview_update_level(game->overview, game->level);
    }
#line 141
    else if (at_entrance) {
        save_get_name("save", game->level, ".txt", name);
        save_info();
    }
#line 143
    else {
#line 145
        save_get_name("save", 0, ".txt", name);
        save_info();
    }
    Blocks * blocks = game->blocks;
    LandFile * f = land_file_new(name, "w");
    char * st = land_strdup(game->hint);
    land_replace_all(& st, "\n", "|");
    land_file_print(f, "hint %s", st);
    land_file_print(f, "title %s", game->title);
    land_free(st);
    float s = 24;
    int n = 0;
    LandArray * arrays [] = {blocks->transparent, blocks->dynamic, blocks->fixed};
    for (int i = 0; i < 3; i += 1) {
        LandArray * array = arrays [i];
        if (! array) {
            continue;
        }
#line 162
        {
#line 162
            LandArrayIterator __iter0__ = LandArrayIterator_first(array);
#line 162
            for (Block * block = LandArrayIterator_item(array, &__iter0__); LandArrayIterator_next(array, &__iter0__); block = LandArrayIterator_item(array, &__iter0__)) {
                float x = block->x / s + 22;
                float y = block->y / s + 4;
                float z = block->z / s + 22;
                int xi = floor(x);
                int yi = floor(y);
                int zi = floor(z);
#line 170
                land_file_print(f, "make %d %d %d %d", block->block_type->btid, xi, yi, zi);
                xi = x * 100 - xi * 100;
                yi = y * 100 - yi * 100;
                zi = z * 100 - zi * 100;
                if (xi || yi || zi) {
                    land_file_print(f, "move %d %d %d", xi, yi, zi);
                }
#line 176
                if (block->frame != 0) {
                    land_file_print(f, "frame %d", block->frame);
                }
#line 178
                n++;
            }
        }
    }
#line 180
    land_file_destroy(f);
#line 182
    print("save_level %s %d", name, n);
}
static void add(SaveInfo * si, float x, float y, float z, float xs, float ys, float zs) {
    float xy [14];
    float * p = xy;
    Viewport v = {0, 0, 1};
    project(& v, x + xs, y + ys, z, p + 0, p + 1);
#line 188
    p += 2;
    project(& v, x, y + ys, z, p + 0, p + 1);
#line 189
    p += 2;
    project(& v, x, y + ys, z + zs, p + 0, p + 1);
#line 190
    p += 2;
    project(& v, x, y, z + zs, p + 0, p + 1);
#line 191
    p += 2;
    project(& v, x + xs, y, z + zs, p + 0, p + 1);
#line 192
    p += 2;
    project(& v, x + xs, y, z, p + 0, p + 1);
#line 193
    p += 2;
    project(& v, x + xs, y + ys, z + zs, p + 0, p + 1);
#line 194
    p += 2;
    si->xy = land_realloc(si->xy, (si->n + 14) * sizeof (float));
    memcpy(si->xy + si->n, xy, sizeof (float) * 14);
    si->n += 14;
}
void save_check(int level) {
    char name [1024];
#line 202
    LandBuffer * f = NULL;
    SaveInfo * si = g_save_info + level;
#line 205
    if (level == game->level) {
        sprintf(name, "data/levels/level%02d.txt", level);
        f = land_buffer_read_from_file(name);
    }
    if (! f) {
        save_get_name("save", level, ".txt", name);
        f = land_buffer_read_from_file(name);
    }
    if (! f) {
#line 213
        return ;
    }
#line 216
    memset(si, 0, sizeof (* si));
#line 218
    si->saved = 1;
#line 220
    LandArray * rows = land_buffer_split(f, "\n");
    land_buffer_destroy(f);
#line 223
    {
#line 223
        LandArrayIterator __iter0__ = LandArrayIterator_first(rows);
#line 223
        for (LandBuffer * rowb = LandArrayIterator_item(rows, &__iter0__); LandArrayIterator_next(rows, &__iter0__); rowb = LandArrayIterator_item(rows, &__iter0__)) {
            char * row = land_buffer_finish(rowb);
            if (land_starts_with(row, "make ")) {
                int t, xi, yi, zi;
                sscanf(row, "make %d %d %d %d", & t, & xi, & yi, & zi);
#line 229
                BlockType * bt = land_array_get_nth(block_types, t);
#line 231
                float x = (xi - 22 - 3) * 24;
                float y = (yi - 4) * 24;
                float z = (zi - 22 - 3) * 24;
#line 235
                if (y < - 5000) {
                    continue;
                }
                if (bt == Render_Scientist) {
                    continue;
                }
                add(si, x, y, z, bt->xs, bt->ys, bt->zs);
#line 243
                if (bt == Render_ExitLeft) {
                    if (xi < 22) {
#line 244
                        si->exits [0] = 1;
                    }
#line 245
                    if (xi > 22) {
#line 245
                        si->exits [1] = 1;
                    }
                }
#line 246
                if (bt == Render_ExitRight) {
                    if (zi < 22) {
#line 247
                        si->exits [2] = 1;
                    }
#line 248
                    if (zi > 22) {
#line 248
                        si->exits [3] = 1;
                    }
                }
            }
#line 250
            land_free(row);
        }
    }
#line 252
    land_array_destroy(rows);
}
static bool workaround_stupid_bug;
void load_level(bool editing, bool at_entrance) {
    workaround_stupid_bug = 1;
    retry:;
    land_pause();
#line 260
    char name [1024];
    Game * self = game;
    self->pristine = 0;
#line 264
    print("Loading %d", game->level);
#line 266
    event("level_up level=%d", game->level);
#line 268
    LandBuffer * f = NULL;
    if (! editing) {
        if (! at_entrance) {
            save_get_name("save", 0, ".txt", name);
            f = land_buffer_read_from_file(name);
        }
#line 273
        if (! f) {
            save_get_name("save", game->level, ".txt", name);
            f = land_buffer_read_from_file(name);
        }
    }
#line 276
    if (! f) {
        if (! editing) {
            print("    failed from %s", name);
        }
#line 279
        sprintf(name, "data/levels/level%02d.txt", game->level);
        f = land_buffer_read_from_file(name);
        self->pristine = 1;
    }
    self->player = NULL;
    self->state = "play";
    self->ticks = 0;
    self->state_tick = 0;
    self->waypoints_count = 0;
    editor->picked = NULL;
    self->lever = NULL;
    self->sequence = 0;
#line 292
    Blocks * blocks = game->blocks;
    blocks_reset(blocks);
#line 295
    if (! f) {
        printf("    failed from %s", name);
        land_unpause();
#line 297
        return ;
    }
#line 300
    save_load_from_offset(f, 0, 0, 0, editing);
#line 302
    int n = 0;
    {
#line 303
        LandArrayIterator __iter0__ = LandArrayIterator_first(blocks->fixed);
#line 303
        for (Block * b = LandArrayIterator_item(blocks->fixed, &__iter0__); LandArrayIterator_next(blocks->fixed, &__iter0__); b = LandArrayIterator_item(blocks->fixed, &__iter0__)) {
            n++;
#line 306
            if (b->block_type == Render_LeverLeft || b->block_type == Render_LeverRight) {
                if (b->frame == 1) {
                    self->lever = b;
                }
            }
#line 309
            if (b->block_type == Render_Waypoint) {
                self->waypoints [b->frame] [0] = b->x;
                self->waypoints [b->frame] [1] = b->y;
                self->waypoints [b->frame] [2] = b->z;
                if (b->frame >= self->waypoints_count) {
                    self->waypoints_count = b->frame + 1;
                }
            }
            // If a level is reloaded, and a flower is not picked (which
            // sets y to somewhere around -9000), it means we failed or
            // reset the level and so ought to get the flower again.
#line 318
            int flower = block_type_flower(b->block_type);
            if (flower) {
                if (b->y > - 8000) {
                    game->flower [flower] = 0;
                }
            }
        }
    }
#line 324
    bool visible = 1;
    for (int i = 1; i < 8; i += 1) {
        visible = visible && self->flower [i];
    }
#line 327
    if (self->key) {
        visible = 0;
    }
#line 329
    if (global_a->editor) {
        visible = 1;
    }
#line 331
    {
#line 331
        LandArrayIterator __iter0__ = LandArrayIterator_first(blocks->dynamic);
#line 331
        for (Block * b = LandArrayIterator_item(blocks->dynamic, &__iter0__); LandArrayIterator_next(blocks->dynamic, &__iter0__); b = LandArrayIterator_item(blocks->dynamic, &__iter0__)) {
            n++;
            if (b->block_type == Render_Key) {
                if (b->y < 9000) {
                    if (! visible) {
                        b->y += 9000;
                    }
                }
#line 336
                else {
#line 338
                    if (visible) {
                        b->y -= 9000;
                    }
                }
            }
        }
    }
#line 341
    if (game->level == game_starting_level) {
        if (! editing && self->pristine) {
            game->sequence = 1;
            game->sequence_ticks = 0;
        }
    }
#line 346
    land_unpause();
#line 348
    if (n == 0) {
        // FIXME: How does that happen?
        save_reset_room(game->level);
        if (workaround_stupid_bug) {
            workaround_stupid_bug = 0;
            goto retry;
        }
    }
}
#line 355
void save_load_from_offset(LandBuffer * f, int ox, int oy, int oz, bool editing) {
    All * all = global_a;
    LandArray * rows = land_buffer_split(f, "\n");
    land_buffer_destroy(f);
    float s = 24;
    int t, xi, yi, zi;
    Blocks * blocks = game->blocks;
    Block * block;
    {
#line 363
        LandArrayIterator __iter0__ = LandArrayIterator_first(rows);
#line 363
        for (LandBuffer * rowb = LandArrayIterator_item(rows, &__iter0__); LandArrayIterator_next(rows, &__iter0__); rowb = LandArrayIterator_item(rows, &__iter0__)) {
            char * row = land_buffer_finish(rowb);
            if (land_starts_with(row, "make ")) {
                sscanf(row, "make %d %d %d %d", & t, & xi, & yi, & zi);
#line 368
                float x = (ox + xi - 22) * s;
                float y = (oy + yi - 4) * s;
                float z = (oz + zi - 22) * s;
#line 372
                BlockType * bt = land_array_get_nth(block_types, t);
                //if bt == Render_ExitLeft or bt == Render_ExitRight:
                //    y -= 0.15 * s
#line 377
                block = block_new(blocks, x, y, z, bt);
#line 379
                block_add(block);
            }
#line 380
            if (land_starts_with(row, "move ")) {
                sscanf(row, "move %d %d %d", & xi, & yi, & zi);
                block->x += xi * s / 100.0;
                block->y += yi * s / 100.0;
                block->z += zi * s / 100.0;
            }
#line 385
            if (land_starts_with(row, "frame ")) {
                sscanf(row, "frame %d", & xi);
                block->frame = xi;
            }
#line 388
            if (land_starts_with(row, "hint ")) {
                char * st = land_strdup(row + 5);
                land_replace_all(& st, "|", "\n");
                if ((! editing) && (all->dpad == 4 || all->dpad == 5)) {
                    land_replace_all(& st, "the D-Pad", "anywhere");
                }
#line 393
                land_string_copy(game->hint, st, 1024);
                land_free(st);
            }
#line 395
            if (land_starts_with(row, "title ")) {
                land_string_copy(game->title, row + 6, 1024);
            }
            land_free(row);
        }
    }
#line 399
    land_array_destroy(rows);
}
void save_reset_room(int i) {
    char name [1024];
    save_get_name("save", i, ".txt", name);
    if (! land_file_remove(name)) {
        land_log_message("Cannot remove %s.", name);
    }
#line 406
    SaveInfo * si = g_save_info + i;
    si->saved = 0;
    game->state = NULL;
#line 410
    save_get_name("save", 0, ".txt", name);
    land_file_remove(name);
}
void save_new(void) {
    for (int i = 1; i < 50; i += 1) {
        save_reset_room(i);
    }
#line 416
    game->level = game_starting_level;
    game->deaths = 0;
    game->key = 0;
    for (int i = 0; i < 8; i += 1) {
        game->flower [i] = 0;
    }
#line 421
    global_a->time = 0;
    save_info();
}
bool save_is_saved(int i) {
    return g_save_info [i].saved;
}
int save_get_level_n(int i) {
    return g_save_info [i].n;
}
float* save_get_level_xy(int i) {
    return g_save_info [i].xy;
}
/* This file was generated by scramble.py. */
