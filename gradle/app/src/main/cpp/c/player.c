/* This file was generated by scramble.py. */
#line 1 "src/player.py"
#include "player.h"
#line 23
Block* player_allocate(void) {
    Player * self;
    land_alloc(self);
    return & self->super;
}
void player_init(Block * super) {
    Player * self = (void *) super;
    self->step = 0;
    self->direction = 0;
    self->want_direction = 0;
    self->rotstep = 0;
    self->pull = 0;
    self->reverse = 0;
    self->stack = land_array_new();
    self->pushing = 0;
    self->dead = 0;
    game->player = self;
}
void player_destroy(Block * super) {
    game->player = NULL;
    Player * self = (void *) super;
    land_array_destroy(self->stack);
    block_destroy(super);
}
void player_try_pull(Player * self, float px, float pz) {
    float ox = self->super.x;
    float oz = self->super.z;
#line 51
    self->super.x -= px * 3 * sqrt(2);
    self->super.z -= pz * 3 * sqrt(2);
    LandArray * pulls = block_colliders((void *) self);
    self->super.x = ox;
    self->super.z = oz;
#line 57
    int tag = block_recursion_tag();
    {
#line 58
        LandArrayIterator __iter0__ = LandArrayIterator_first(pulls);
#line 58
        for (Block * p = LandArrayIterator_item(pulls, &__iter0__); LandArrayIterator_next(pulls, &__iter0__); p = LandArrayIterator_item(pulls, &__iter0__)) {
            if (! p->block_type->dynamic) {
#line 59
                continue;
            }
#line 60
            if (p->block_type->fixed) {
#line 60
                continue;
            }
#line 61
            p->recursion_prevention = tag;
            if (block_pull(p, px, 0, pz)) {
                self->super.dx = 0;
                self->super.dz = 0;
                self->pushing = 1;
            }
        }
    }
#line 67
    land_array_destroy(pulls);
}
void player_grab(Player * self) {
    float ox = self->super.x;
    float oz = self->super.z;
#line 73
    float px = sin((self->want_direction + 1) * pi / 4);
    float pz = cos((self->want_direction + 1) * pi / 4);
#line 76
    self->super.x += px * 3 * sqrt(2);
    self->super.z += pz * 3 * sqrt(2);
    LandArray * grabs = block_colliders(& self->super);
#line 80
    self->super.x = ox;
    self->super.z = oz;
#line 83
    land_array_clear(self->stack);
#line 85
    float max_y = - 9000;
    {
#line 86
        LandArrayIterator __iter0__ = LandArrayIterator_first(grabs);
#line 86
        for (Block * b = LandArrayIterator_item(grabs, &__iter0__); LandArrayIterator_next(grabs, &__iter0__); b = LandArrayIterator_item(grabs, &__iter0__)) {
            if (! b->block_type->lift) {
#line 87
                continue;
            }
#line 88
            if (b->y >= max_y) {
#line 88
                max_y = b->y;
            }
        }
    }
#line 90
    {
#line 90
        LandArrayIterator __iter0__ = LandArrayIterator_first(grabs);
#line 90
        for (Block * b = LandArrayIterator_item(grabs, &__iter0__); LandArrayIterator_next(grabs, &__iter0__); b = LandArrayIterator_item(grabs, &__iter0__)) {
            if (! b->block_type->lift) {
#line 91
                continue;
            }
#line 92
            if (b->y == max_y) {
                land_array_add(self->stack, b);
            }
        }
    }
#line 95
    land_array_destroy(grabs);
}
void player_lift(Player * self) {
    block_recursion_tag();
#line 100
    {
#line 100
        LandArrayIterator __iter0__ = LandArrayIterator_first(self->stack);
#line 100
        for (Block * p = LandArrayIterator_item(self->stack, &__iter0__); LandArrayIterator_next(self->stack, &__iter0__); p = LandArrayIterator_item(self->stack, &__iter0__)) {
            // don't want to be able to walk under it
#line 103
            if (p->y + 1 < self->super.y + self->super.ys) {
                if (block_pull(p, 0, 1, 0)) {
                    p->no_fall = 1;
                    p->dy = 0;
                }
            }
        }
    }
}
#line 108
void player_tick(Block * super) {
#line 110
    Player * self = (void *) super;
#line 112
    All * a = global_a;
#line 114
    float x = 0;
    float z = 0;
    float sx = 0;
    float sz = 0;
    int ns = 0;
    if (a->up) {
        x -= 1;
        z -= 1;
        ns++;
    }
#line 123
    if (a->down) {
        x += 1;
        z += 1;
        ns++;
    }
#line 127
    if (a->left) {
        x -= 1;
        z += 1;
        ns++;
    }
#line 131
    if (a->right) {
        x += 1;
        z -= 1;
        ns++;
    }
#line 135
    if (ns > 0) {
        sx -= a->up_s;
        sz -= a->up_s;
        sx += a->down_s;
        sz += a->down_s;
        sx -= a->left_s;
        sz += a->left_s;
        sx += a->right_s;
        sz -= a->right_s;
        self->accel++;
        if (self->accel > 120) {
            self->accel = 120;
        }
    }
#line 146
    else {
#line 148
        self->accel = 0;
    }
#line 149
    if (sx > 1) {
#line 149
        sx = 1;
    }
#line 150
    if (sz > 1) {
#line 150
        sz = 1;
    }
#line 151
    if (sx < - 1) {
#line 151
        sx = - 1;
    }
#line 152
    if (sz < - 1) {
#line 152
        sz = - 1;
    }
#line 153
    if (game->record->is_replaying || game->record->is_recording || game->sequence) {
        sx = 0;
        sz = 0;
        self->accel = 0;
    }
#line 156
    else {
#line 158
        x = sx;
        z = sz;
    }
    bool push_animation = 0;
    // slow down jump stronger if only tapping
#line 164
    if (! a->jump && self->super.dy > 0) {
        self->super.dy *= 0.5;
    }
    float s = pow(sx * sx + sz * sz, 0.5);
    float d = pow(x * x + z * z, 0.5);
    if (d > 0 && ! land_array_count(self->stack)) {
#line 171
        x /= d;
        z /= d;
        if (s > 0 && s < 1) {
            x *= s;
            z *= s;
        }
#line 176
        double angle = atan2(x, z) - pi / 4;
        angle = angle / (2 * pi);
        angle = (int)((angle - floor(angle)) * 8 + 0.5) & 7;
#line 180
        self->want_direction = angle;
#line 182
        if ((super->ground || (a->godmode && self->super.dy < 5)) && a->jump) {
            if (self->pull) {
                if (! self->reverse) {
                    player_grab(self);
                    if (land_array_count(self->stack)) {
                        x = z = 0;
                        self->super.dx = 0;
                        self->super.dz = 0;
                        self->pull = 0;
                    }
#line 190
                    else {
#line 192
                        self->reverse = 1;
                    }
                }
#line 194
                if (self->reverse) {
                    self->want_direction += 4;
                    self->want_direction &= 7;
                }
            }
#line 198
            else if (a->jump) {
                self->super.dy += 30;
                sound(Render_uhg, 1);
            }
        }
#line 202
        if (self->accel > 15) {
            float f = (self->accel - 15.0) / (120 - 15);
            x *= 1 + f / 2;
            z *= 1 + f / 2;
        }
        x *= 2.8;
        z *= 2.8;
#line 210
        super->dx += x;
        super->dz += z;
#line 213
        self->step += 1;
        self->step &= 31;
#line 216
        if (self->step == 9 || self->step == 25) {
            if (self->super.ground) {
                if (self->metal) {
#line 218
                    sound(Render_metal, 0.3);
                }
#line 218
                else {
                    sound(Render_step, 0.3);
                }
            }
        }
    }
#line 219
    else {
#line 222
        if (self->step != 8 && self->step != 24) {
            self->step += 1;
            self->step &= 31;
        }
#line 224
        else {
#line 226
            self->lever = 0;
        }
        if (super->ground && a->jump) {
            self->pull = 1;
        }
    }
#line 231
    if (self->pushing) {
        if (game->ticks % 8 == 1) {
            sound(Render_push, 0.3);
            self->pushing = 0;
        }
    }
#line 236
    if (self->want_direction != self->direction) {
        self->rotstep += 1;
        if (self->rotstep >= 4) {
            self->rotstep = 0;
            d = self->want_direction - self->direction;
#line 242
            if (d < - 4) {
#line 242
                d += 8;
            }
#line 243
            else if (d > 4) {
#line 243
                d -= 8;
            }
#line 244
            if (abs(d) == 4) {
#line 244
                self->direction += (land_rand(0, 1)) * 2 - 1;
            }
#line 245
            else if (d < 0) {
#line 245
                self->direction -= 1;
            }
#line 246
            else if (d > 0) {
#line 246
                self->direction += 1;
            }
#line 247
            self->direction &= 7;
        }
    }
#line 249
    super->frame = self->direction * 8 + self->step / 4;
#line 251
    float px = super->dx;
    float pz = super->dz;
#line 254
    if (super->pushed_something) {
        super->pushed_something = 0;
        super->dx *= 0.7;
        super->dz *= 0.7;
        push_animation = 1;
    }
    block_tick(super);
#line 262
    if (self->pull) {
        if (! a->jump) {
            self->pull = 0;
            self->reverse = 0;
        }
        if (px || pz) {
            float px2 = px;
            float pz2 = pz;
            float fx = fabs(px2);
            float fz = fabs(pz2);
            // for gamepad, strongly prefer pulling in the cardinal directions
            if (fx < 0.5 * fz) {
                px2 = 0;
            }
#line 275
            else if (fz < 0.5 * fx) {
                pz2 = 0;
            }
#line 277
            player_try_pull(self, px2, pz2);
            push_animation = 1;
        }
    }
#line 280
    if (land_array_count(self->stack)) {
        if (! a->jump) {
            while (land_array_count(self->stack)) {
                Block * b = land_array_pop(self->stack);
                b->no_fall = 0;
            }
        }
#line 284
        else {
#line 286
            player_lift(self);
            push_animation = 1;
        }
    }
#line 289
    if (! super->ground && a->jump) {
        push_animation = 1;
    }
    if (push_animation) {
        super->frame += 64;
    }
}
#line 295
void player_touch(Block * super, Block * c, float dx, float dy, float dz) {
    All * a = global_a;
    Player * self = (void *) super;
    cube_touch(super, c, dx, dy, dz);
    if (c->block_type == Render_Gremlin) {
        Gremlin * gremlin = (void *) c;
        if (! gremlin->respect) {
            self->dead = 1;
        }
    }
#line 303
    int flower = 0;
    if (c->block_type == Render_Car) {
        if (game->key && game->sequence == 0) {
            LandArray * cs = block_colliders(c);
            int n = land_array_count(cs);
            land_array_destroy(cs);
            if (n == 0) {
                sound(Render_ignition, .5);
                game->sequence = 2;
                game->sequence_ticks = 0;
            }
        }
    }
#line 313
    if (c->block_type == Render_Gentian) {
        flower = 1;
    }
#line 315
    if (c->block_type == Render_Edelweiss) {
        flower = 2;
    }
#line 317
    if (c->block_type == Render_Orchid) {
        flower = 3;
    }
#line 319
    if (c->block_type == Render_Hyacinth) {
        flower = 4;
    }
#line 321
    if (c->block_type == Render_Sunflower) {
        flower = 5;
    }
#line 323
    if (c->block_type == Render_Rose) {
        flower = 6;
    }
#line 325
    if (c->block_type == Render_Belladonna) {
        flower = 7;
    }
#line 327
    if (c->block_type == Render_TestTube) {
        if (! game->test_tube [c->frame + 1]) {
            game->test_tube [c->frame + 1] = 1;
            sound(Render_on, 1);
            c->y = - 9000;
        }
    }
#line 332
    if (flower) {
        c->y = - 9000;
        game->flower [flower] = 1;
        sound(Render_pickup, 1);
    }
#line 336
    if (c->block_type == Render_Key) {
        c->y = - 9000;
        game->key = 1;
        sound(Render_pickup, 1);
    }
#line 340
    if (dy < 0) {
        bool always = a->godmode || game->record->wait_on_level;
        if (c->block_type == Render_ExitLeft && c->frame != 4) {
            if (c->frame == 1 || c->frame == 2 || always) {
                if (block_center_overlaps(super, c)) {
                    game_level_done(game, c->x > 0 ? 1 : - 1, 0);
                }
            }
        }
#line 346
        else if (c->block_type == Render_ExitRight && c->frame != 4) {
            if (c->frame == 1 || c->frame == 2 || always) {
                if (block_center_overlaps(super, c)) {
                    game_level_done(game, 0, c->z > 0 ? 1 : - 1);
                }
            }
        }
#line 350
        if (c->block_type == Render_GrateBottom || c->block_type == Render_Cart) {
            self->metal = 1;
        }
#line 351
        else {
#line 353
            self->metal = 0;
        }
    }
#line 354
    if (! self->lever) {
        if (dx < 0 && c->block_type == Render_LeverLeft) {
            if (c->frame == 0) {
                self->lever = 1;
                c->frame = 1;
                game->lever = c;
            }
        }
#line 360
        if (dz < 0 && c->block_type == Render_LeverRight) {
            if (c->frame == 0) {
                self->lever = 1;
                c->frame = 1;
                game->lever = c;
            }
        }
    }
#line 365
    if (dx != 0 || dz != 0) {
        if (c->block_type->dynamic) {
            self->pushing = 1;
        }
    }
}
#line 369
void player_find_entrance(Block * super) {
    int mind = 0;
    Block * e = NULL;
    {
#line 372
        LandArrayIterator __iter0__ = LandArrayIterator_first(super->blocks->fixed);
#line 372
        for (Block * b = LandArrayIterator_item(super->blocks->fixed, &__iter0__); LandArrayIterator_next(super->blocks->fixed, &__iter0__); b = LandArrayIterator_item(super->blocks->fixed, &__iter0__)) {
            if (game->gox && b->block_type == Render_ExitLeft && b->frame != 4) {
                if (game->gox * b->x < 0) {
                    int d = fabs(game->ez - b->z);
                    if (e == NULL || d < mind) {
                        mind = d;
                        e = b;
                    }
                }
            }
#line 379
            if (game->goz && b->block_type == Render_ExitRight && b->frame != 4) {
                if (game->goz * b->z < 0) {
                    int d = fabs(game->ex - b->x);
                    if (e == NULL || d < mind) {
                        mind = d;
                        e = b;
                    }
                }
            }
        }
    }
#line 385
    if (e) {
        super->x = e->x + e->xs / 2 + game->gox * (e->xs / 2 + super->xs / 2) - super->xs / 2;
        super->y = e->y + e->ys;
        super->z = e->z + e->zs / 2 + game->goz * (e->zs / 2 + super->zs / 2) - super->zs / 2;
        if (e->frame == 3) {
            e->frame = 2;
        }
    }
#line 392
    LandArray * a = block_colliders(super);
    {
#line 393
        LandArrayIterator __iter0__ = LandArrayIterator_first(a);
#line 393
        for (Block * c = LandArrayIterator_item(a, &__iter0__); LandArrayIterator_next(a, &__iter0__); c = LandArrayIterator_item(a, &__iter0__)) {
            if (super->y < c->y + c->ys) {
                super->y = c->y + c->ys;
            }
        }
    }
#line 397
    land_array_destroy(a);
}
/* This file was generated by scramble.py. */
